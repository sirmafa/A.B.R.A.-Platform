AWSTemplateFormatVersion: '2010-09-09'
Description: 'Fix CORS for A.B.R.A. API Gateway'

Parameters:
  ApiGatewayId:
    Type: String
    Default: '72a2dojacb'
    Description: 'Existing API Gateway ID'

Resources:
  # Update Lambda Functions with proper CORS headers
  UpdateRequestPatFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: abra-platform-prod-requestPat
      Runtime: nodejs18.x
      Handler: index.handler
      Role: arn:aws:iam::898133201826:role/abra-platform-prod-us-east-1-lambdaRole
      Code:
        ZipFile: |
          const AWS = require('aws-sdk');
          const crypto = require('crypto');
          const dynamodb = new AWS.DynamoDB.DocumentClient();
          
          exports.handler = async (event) => {
            const headers = {
              'Access-Control-Allow-Origin': '*',
              'Access-Control-Allow-Headers': 'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token',
              'Access-Control-Allow-Methods': 'POST,OPTIONS'
            };
            
            if (event.httpMethod === 'OPTIONS') {
              return { statusCode: 200, headers, body: '' };
            }
            
            try {
              const { userId, companyId } = JSON.parse(event.body);
              const patToken = 'PAT-' + crypto.randomBytes(8).toString('hex').toUpperCase();
              const expiry = Date.now() + 900000;
              
              // Anchor to DLT
              const anchorId = crypto.randomUUID();
              const patHash = crypto.createHash('sha256').update(patToken + userId).digest('hex');
              
              await dynamodb.put({
                TableName: 'ABRA-DLT-Ledger',
                Item: {
                  anchorId,
                  hash: patHash,
                  type: 'PAT_ISSUED',
                  timestamp: Date.now(),
                  metadata: { userId, companyId, expiry }
                }
              }).promise();
              
              return {
                statusCode: 200,
                headers,
                body: JSON.stringify({
                  token: patToken,
                  expiry,
                  message: 'PAT issued via JIT Access Gate. Hash anchored on DLT.'
                })
              };
            } catch (error) {
              return {
                statusCode: 500,
                headers,
                body: JSON.stringify({ error: error.message })
              };
            }
          };

  UpdateAnchorProofFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: abra-platform-prod-anchorProof
      Runtime: nodejs18.x
      Handler: index.handler
      Role: arn:aws:iam::898133201826:role/abra-platform-prod-us-east-1-lambdaRole
      Code:
        ZipFile: |
          const AWS = require('aws-sdk');
          const crypto = require('crypto');
          const dynamodb = new AWS.DynamoDB.DocumentClient();
          
          exports.handler = async (event) => {
            const headers = {
              'Access-Control-Allow-Origin': '*',
              'Access-Control-Allow-Headers': 'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token',
              'Access-Control-Allow-Methods': 'POST,OPTIONS'
            };
            
            if (event.httpMethod === 'OPTIONS') {
              return { statusCode: 200, headers, body: '' };
            }
            
            try {
              const { hash } = JSON.parse(event.body);
              
              if (!hash || hash.length !== 64) {
                return {
                  statusCode: 400,
                  headers,
                  body: JSON.stringify({ error: 'Invalid hash format. Must be SHA-256.' })
                };
              }
              
              const anchorId = crypto.randomUUID();
              const blockHeight = Math.floor(Date.now() / 1000);
              
              await dynamodb.put({
                TableName: 'ABRA-DLT-Ledger',
                Item: {
                  anchorId,
                  hash,
                  type: 'BACKUP_PROOF',
                  timestamp: Date.now(),
                  blockHeight,
                  metadata: { source: 'A.B.R.A-Platform' }
                }
              }).promise();
              
              return {
                statusCode: 200,
                headers,
                body: JSON.stringify({
                  success: true,
                  message: 'Backup Proof successfully anchored to DLT.',
                  hash,
                  anchorId,
                  blockHeight
                })
              };
            } catch (error) {
              return {
                statusCode: 500,
                headers,
                body: JSON.stringify({ error: error.message })
              };
            }
          };

  UpdateVerifyProofFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: abra-platform-prod-verifyProof
      Runtime: nodejs18.x
      Handler: index.handler
      Role: arn:aws:iam::898133201826:role/abra-platform-prod-us-east-1-lambdaRole
      Code:
        ZipFile: |
          const AWS = require('aws-sdk');
          const dynamodb = new AWS.DynamoDB.DocumentClient();
          
          exports.handler = async (event) => {
            const headers = {
              'Access-Control-Allow-Origin': '*',
              'Access-Control-Allow-Headers': 'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token',
              'Access-Control-Allow-Methods': 'POST,OPTIONS'
            };
            
            if (event.httpMethod === 'OPTIONS') {
              return { statusCode: 200, headers, body: '' };
            }
            
            try {
              const { currentHash } = JSON.parse(event.body);
              
              const result = await dynamodb.query({
                TableName: 'ABRA-DLT-Ledger',
                IndexName: 'TypeTimestampIndex',
                KeyConditionExpression: '#type = :type',
                ExpressionAttributeNames: { '#type': 'type' },
                ExpressionAttributeValues: { ':type': 'BACKUP_PROOF' },
                ScanIndexForward: false,
                Limit: 1
              }).promise();
              
              const anchoredProof = result.Items[0];
              const isMatch = anchoredProof && currentHash === anchoredProof.hash;
              
              return {
                statusCode: 200,
                headers,
                body: JSON.stringify({
                  isMatch,
                  status: isMatch ? 'VERIFIED-CLEAN' : 'COMPROMISED',
                  anchoredHash: anchoredProof?.hash,
                  anchorTimestamp: anchoredProof?.timestamp,
                  blockHeight: anchoredProof?.blockHeight
                })
              };
            } catch (error) {
              return {
                statusCode: 500,
                headers,
                body: JSON.stringify({ error: error.message })
              };
            }
          };